version: "3.9"

networks:
  dbnet:

volumes:
  pg_0_data:
  pg_1_data:
  pg_2_data:
  pg_logs:
 # pgbadger_data:
  grafana-data:

services:
  # NODO PRINCIPAL
  pg-0:
    image: bitnamilegacy/postgresql-repmgr:16
    container_name: pg-0
    cap_add:
      - NET_ADMIN
    restart: unless-stopped
    networks: [dbnet]
    environment:
      - POSTGRESQL_POSTGRES_PASSWORD=${POSTGRESQL_POSTGRES_PASSWORD}
      - POSTGRESQL_USERNAME=${POSTGRESQL_USERNAME}
      - POSTGRESQL_PASSWORD=${POSTGRESQL_PASSWORD}
      - POSTGRESQL_DATABASE=${POSTGRESQL_DATABASE}
      - REPMGR_PASSWORD=${REPMGR_PASSWORD}
      - REPMGR_PRIMARY_HOST=pg-0
      - REPMGR_NODE_NAME=pg-0
      - REPMGR_NODE_NETWORK_NAME=pg-0
      - REPMGR_PARTNER_NODES=pg-0,pg-1,pg-2
      - POSTGRESQL_CLUSTER_APP_NAME=appcluster
    volumes:
      - pg_0_data:/bitnami/postgresql
    ports:
      - "5433:5432"

  # REPLICA 1
  pg-1:
    image: bitnamilegacy/postgresql-repmgr:16
    container_name: pg-1
    cap_add:
      - NET_ADMIN
    restart: unless-stopped
    networks: [dbnet]
    environment:
      - POSTGRESQL_POSTGRES_PASSWORD=${POSTGRESQL_POSTGRES_PASSWORD}
      - POSTGRESQL_USERNAME=${POSTGRESQL_USERNAME}
      - POSTGRESQL_PASSWORD=${POSTGRESQL_PASSWORD}
      - POSTGRESQL_DATABASE=${POSTGRESQL_DATABASE}
      - REPMGR_PASSWORD=${REPMGR_PASSWORD}
      - REPMGR_PRIMARY_HOST=pg-0
      - REPMGR_NODE_NAME=pg-1
      - REPMGR_NODE_NETWORK_NAME=pg-1
      - REPMGR_PARTNER_NODES=pg-0,pg-1,pg-2
      - POSTGRESQL_CLUSTER_APP_NAME=appcluster
    volumes:
      - pg_1_data:/bitnami/postgresql

  # REPLICA 2
  pg-2:
    image: bitnamilegacy/postgresql-repmgr:16
    container_name: pg-2
    cap_add:
      - NET_ADMIN
    restart: unless-stopped
    networks: [dbnet]
    environment:
      - POSTGRESQL_POSTGRES_PASSWORD=${POSTGRESQL_POSTGRES_PASSWORD}
      - POSTGRESQL_USERNAME=${POSTGRESQL_USERNAME}
      - POSTGRESQL_PASSWORD=${POSTGRESQL_PASSWORD}
      - POSTGRESQL_DATABASE=${POSTGRESQL_DATABASE}
      - REPMGR_PASSWORD=${REPMGR_PASSWORD}
      - REPMGR_PRIMARY_HOST=pg-0
      - REPMGR_NODE_NAME=pg-2
      - REPMGR_NODE_NETWORK_NAME=pg-2
      - REPMGR_PARTNER_NODES=pg-0,pg-1,pg-2
      - POSTGRESQL_CLUSTER_APP_NAME=appcluster
    volumes:
      - pg_2_data:/bitnami/postgresql

  # BALANCEADOR Y FAILOVER
  pgpool:
    image: bitnamilegacy/pgpool:4
    container_name: pgpool
    restart: unless-stopped
    networks: [dbnet]
    depends_on: [pg-0, pg-1, pg-2]
    environment:
      - PGPOOL_BACKEND_NODES=0:pg-0:5432,1:pg-1:5432,2:pg-2:5432
      - PGPOOL_SR_CHECK_USER=${PGPOOL_SR_CHECK_USER}
      - PGPOOL_SR_CHECK_PASSWORD=${PGPOOL_SR_CHECK_PASSWORD}
      - PGPOOL_POSTGRES_USERNAME=postgres
      - PGPOOL_POSTGRES_PASSWORD=${POSTGRESQL_POSTGRES_PASSWORD}
      - POSTGRESQL_USERNAME=${POSTGRESQL_USERNAME}
      - POSTGRESQL_PASSWORD=${POSTGRESQL_PASSWORD}
      - POSTGRESQL_DATABASE=${POSTGRESQL_DATABASE}
      - PGPOOL_ENABLE_LOAD_BALANCING=yes
      - PGPOOL_ADMIN_USERNAME=admin
      - PGPOOL_ADMIN_PASSWORD=${PGPOOL_ADMIN_PASSWORD}
    ports:
      - "5432:5432"

  # CLIENTE WEB
  pgadmin:
    image: dpage/pgadmin4
    container_name: pgadmin
    restart: unless-stopped
    environment:
      - PGADMIN_DEFAULT_EMAIL=admin@admin.com
      - PGADMIN_DEFAULT_PASSWORD=admin
    ports:
      - "8080:80"
    networks:
      - dbnet

  pgbackups:
    image: prodrigestivill/postgres-backup-local
    container_name: pgbackups
    restart: unless-stopped
    networks: [dbnet]
    environment:
      - POSTGRES_HOST=pgpool
      - POSTGRES_DB=${POSTGRESQL_DATABASE}
      - POSTGRES_USER=${POSTGRESQL_USERNAME}
      - POSTGRES_PASSWORD=${POSTGRESQL_PASSWORD}
      - SCHEDULE=@daily
      - BACKUP_KEEP_DAYS=7
      - BACKUP_KEEP_WEEKS=4
      - BACKUP_KEEP_MONTHS=6
    volumes:
      - ./backups:/backups

  pgoptimizer:
    image: postgres:16
    container_name: pgoptimizer
    restart: unless-stopped
    networks: [dbnet]
    depends_on:
      - pgpool
    
    environment:
      - PGPASSWORD=${POSTGRESQL_POSTGRES_PASSWORD}
      - PGUSER=postgres
      - PGDATABASE=${POSTGRESQL_DATABASE}
      - PGHOST=pgpool
    
    volumes:
      - ./scripts/maintenance:/scripts
      
    command: |  # <--- ¬°ESTE ES EL CAMBIO! (De '>' a '|')
      bash -c "
      echo 'üîÑ Iniciando optimizador de base de datos...';
      
      echo '‚è≥ Esperando a que pgpool est√© listo...';
      while ! pg_isready -h pgpool -U postgres -d ${POSTGRESQL_DATABASE} -q; do
        echo 'pgpool no est√° listo, reintentando en 10 segundos...';
        sleep 10;
      done;
      
      echo '‚úÖ pgpool est√° listo. Iniciando ciclo de mantenimiento.';
      
      while true; do
        echo 'üßπ Ejecutando VACUUM ANALYZE...';
        psql -c 'VACUUM (VERBOSE, ANALYZE);';
        
        echo 'üîß Ejecutando REINDEX DATABASE...';
        psql -c 'REINDEX DATABASE ${POSTGRESQL_DATABASE};';
        
        echo '‚úÖ Mantenimiento completado. Esperando 24 horas...';
        sleep 86400;
      done"
  # ... (tus otros servicios: pg-2, pgpool, pgadmin, pgbackups, etc.)

  # APLICACI√ìN WEB - BACKEND
  backend-app: # <--- Le damos un nombre de servicio simple
    image: maxisanchez27/hia-backend:latest # <-- A√ëADIMOS ESTA
    container_name: backend-app
    restart: unless-stopped
    ports:
      # Expone el puerto 3000 de tu app al puerto 3000 de tu PC
      # Cambia "3000" si tu app corre en otro puerto
      - "3000:3000"
    networks:
      - dbnet
    depends_on:
      - pgpool # Se asegura de que pgpool inicie primero
    # --- ¬°ESTA ES LA L√çNEA M√ÅGICA! ---
    env_file:
      - ./backend_FJV/.env  # Inyecta todos los secretos de este archivo
    environment:
      # --- Conexi√≥n a PGPOOL usando tus variables ---
      - DB_HOST=pgpool
      - DB_PORT=5432
      - DB_NAME=${POSTGRESQL_DATABASE}
      - DB_USER=${POSTGRESQL_USERNAME}   # Usuario de la APP
      - DB_PASSWORD=${POSTGRESQL_PASSWORD} # Clave del usuario de la APP
      - DB_LOGGING=false
      # (A√±ade aqu√≠ cualquier otra variable que tu back necesite)

  # APLICACI√ìN WEB - FRONTEND
  frontend-app: # <--- Nombre de servicio para el frontend
    image: maxisanchez27/hia-frontend:latest # <-- A√ëADIMOS ESTA
    container_name: frontend-app
    restart: unless-stopped
    ports:
      # Expone el frontend en el puerto 80 (HTTP) de tu PC
      - "80:80"
    networks:
      - dbnet # Lo ponemos en la misma red
    depends_on:
      - backend-app # Se asegura de que el backend inicie primero
  # --- SERVICIOS DE MONITOREO ---

  prometheus:
    image: prom/prometheus:v2.47.1
    container_name: prometheus
    restart: unless-stopped
    networks: [dbnet]
    ports:
      - "9090:9090"
    volumes:
      - ./config/prometheus.yml:/etc/prometheus/prometheus.yml
    profiles: ["monitoring"] # <-- PERFIL

  grafana:
    image: grafana/grafana:10.1.5
    container_name: grafana
    restart: unless-stopped
    networks: [dbnet]
    ports:
      - "3001:3000"
    volumes:
      - grafana-data:/var/lib/grafana
    profiles: ["monitoring"] # <-- PERFIL

  # ... (justo despu√©s de grafana)

  cadvisor:
    image: gcr.io/cadvisor/cadvisor:v0.47.2
    container_name: cadvisor
    restart: unless-stopped
    networks: [dbnet]
    volumes:
      # --- ESTA SECCI√ìN EST√Å CORREGIDA PARA WINDOWS ---
      - /:/rootfs:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro # <-- Usamos el "socket" de Docker
      - /sys:/sys:ro
      # Quitamos las l√≠neas que daban error en Windows
      # - /var/lib/docker/:/var/lib/docker:ro
      # - /dev/disk/:/dev/disk:ro
    profiles: ["monitoring"]

  pg_exporter:
    image: quay.io/prometheuscommunity/postgres-exporter:v0.15.0
    container_name: pg_exporter
    restart: unless-stopped
    networks: [dbnet]
    environment:
      - DATA_SOURCE_NAME=postgresql://postgres:${POSTGRESQL_POSTGRES_PASSWORD}@pgpool:5432/${POSTGRESQL_DATABASE}?sslmode=disable
    depends_on:
      - pgpool
    profiles: ["monitoring"] # <-- PERFIL

  # 5. DESPLIEGUE CONTINUO (Punto 5 - Watchtower)
  watchtower:
    image: containrrr/watchtower
    container_name: watchtower
    restart: unless-stopped
    volumes:
      # Permite a Watchtower controlar el "motor" de Docker
      - /var/run/docker.sock:/var/run/docker.sock
    # Revisa cada 30s, limpia im√°genes viejas,
    # y monitorea *solo* backend-app y frontend-app
    command: --interval 30 --cleanup backend-app frontend-app
    profiles: ["monitoring"] # Lo a√±adimos al perfil de monitoreo