version: "3.9"

networks:
  dbnet:

volumes:
  pg_0_data:
  pg_1_data:
  pg_2_data:
  pg_logs:
  # pgbadger_data:
  grafana-data:

services:
  # NODO PRINCIPAL
  pg-0:
    image: bitnamilegacy/postgresql-repmgr:16
    container_name: pg-0
    cap_add:
      - NET_ADMIN
    restart: unless-stopped
    networks: [dbnet]
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "pg_isready -U ${POSTGRESQL_USERNAME} -d ${POSTGRESQL_DATABASE} -h localhost",
        ]
      interval: 10s
      timeout: 5s
      retries: 12
    environment:
      - REPMGR_NODE_ID=1
      - POSTGRESQL_POSTGRES_PASSWORD=${POSTGRESQL_POSTGRES_PASSWORD}
      - POSTGRESQL_USERNAME=${POSTGRESQL_USERNAME}
      - POSTGRESQL_PASSWORD=${POSTGRESQL_PASSWORD}
      - POSTGRESQL_DATABASE=${POSTGRESQL_DATABASE}
      - REPMGR_PASSWORD=${REPMGR_PASSWORD}
      - REPMGR_PRIMARY_HOST=pg-0
      - REPMGR_NODE_NAME=pg-0
      - REPMGR_NODE_NETWORK_NAME=pg-0
      - REPMGR_PARTNER_NODES=pg-0,pg-1,pg-2
      - POSTGRESQL_CLUSTER_APP_NAME=appcluster
      - REPMGRD_ENABLED=yes
      - REPMGRD_FAILOVER=automatic
      - REPMGRD_PROMOTE_COMMAND=repmgr standby promote -f /opt/bitnami/repmgr/repmgr.conf
      - REPMGRD_FOLLOW_COMMAND=repmgr standby follow -f /opt/bitnami/repmgr/repmgr.conf
    volumes:
      - pg_0_data:/bitnami/postgresql
    ports:
      - "5433:5432"

  # REPLICA 1
  pg-1:
    image: bitnamilegacy/postgresql-repmgr:16
    container_name: pg-1
    cap_add:
      - NET_ADMIN
    restart: unless-stopped
    networks: [dbnet]
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "pg_isready -U ${POSTGRESQL_USERNAME} -d ${POSTGRESQL_DATABASE} -h localhost",
        ]
      interval: 10s
      timeout: 5s
      retries: 12
    environment:
      - REPMGR_NODE_ID=2
      - POSTGRESQL_POSTGRES_PASSWORD=${POSTGRESQL_POSTGRES_PASSWORD}
      - POSTGRESQL_USERNAME=${POSTGRESQL_USERNAME}
      - POSTGRESQL_PASSWORD=${POSTGRESQL_PASSWORD}
      - POSTGRESQL_DATABASE=${POSTGRESQL_DATABASE}
      - REPMGR_PASSWORD=${REPMGR_PASSWORD}
      - REPMGR_PRIMARY_HOST=pg-0
      - REPMGR_NODE_NAME=pg-1
      - REPMGR_NODE_NETWORK_NAME=pg-1
      - REPMGR_PARTNER_NODES=pg-0,pg-1,pg-2
      - POSTGRESQL_CLUSTER_APP_NAME=appcluster
      - REPMGRD_ENABLED=yes
      - REPMGRD_FAILOVER=automatic
      - REPMGRD_PROMOTE_COMMAND=repmgr standby promote -f /opt/bitnami/repmgr/repmgr.conf
      - REPMGRD_FOLLOW_COMMAND=repmgr standby follow -f /opt/bitnami/repmgr/repmgr.conf
    volumes:
      - pg_1_data:/bitnami/postgresql

  # REPLICA 2
  pg-2:
    image: bitnamilegacy/postgresql-repmgr:16
    container_name: pg-2
    cap_add:
      - NET_ADMIN
    restart: unless-stopped
    networks: [dbnet]
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "pg_isready -U ${POSTGRESQL_USERNAME} -d ${POSTGRESQL_DATABASE} -h localhost",
        ]
      interval: 10s
      timeout: 5s
      retries: 12
    environment:
      - REPMGR_NODE_ID=3
      - POSTGRESQL_POSTGRES_PASSWORD=${POSTGRESQL_POSTGRES_PASSWORD}
      - POSTGRESQL_USERNAME=${POSTGRESQL_USERNAME}
      - POSTGRESQL_PASSWORD=${POSTGRESQL_PASSWORD}
      - POSTGRESQL_DATABASE=${POSTGRESQL_DATABASE}
      - REPMGR_PASSWORD=${REPMGR_PASSWORD}
      - REPMGR_PRIMARY_HOST=pg-0
      - REPMGR_NODE_NAME=pg-2
      - REPMGR_NODE_NETWORK_NAME=pg-2
      - REPMGR_PARTNER_NODES=pg-0,pg-1,pg-2
      - POSTGRESQL_CLUSTER_APP_NAME=appcluster
      - REPMGRD_ENABLED=yes
      - REPMGRD_FAILOVER=automatic
      - REPMGRD_PROMOTE_COMMAND=repmgr standby promote -f /opt/bitnami/repmgr/repmgr.conf
      - REPMGRD_FOLLOW_COMMAND=repmgr standby follow -f /opt/bitnami/repmgr/repmgr.conf
    volumes:
      - pg_2_data:/bitnami/postgresql

  # BALANCEADOR Y FAILOVER
  pgpool:
    image: bitnamilegacy/pgpool:4 # Imagen oficial de Pgpool-II con soporte para clustering y failover
    container_name: pgpool
    restart: unless-stopped
    networks: [dbnet]
    depends_on:
      pg-0:
        condition: service_healthy
      pg-1:
        condition: service_healthy
      pg-2:
        condition: service_healthy

    environment:
      # üóÇÔ∏è Definici√≥n de los nodos backend
      # Este formato (sin roles) es el correcto para la variable de Bitnami
      - PGPOOL_BACKEND_NODES=0:pg-0:5432:1:1,1:pg-1:5432:1:1,2:pg-2:5432:1:1

      # Nombres descriptivos de los nodos
      - PGPOOL_BACKEND_APPLICATION_NAMES=pg-0,pg-1,pg-2

      # üë§ Usuario de chequeo de replicaci√≥n
      - PGPOOL_SR_CHECK_USER=${PGPOOL_SR_CHECK_USER}
      - PGPOOL_SR_CHECK_PASSWORD=${PGPOOL_SR_CHECK_PASSWORD}

      # üë§ Usuario superadmin de PostgreSQL (postgres)
      - PGPOOL_POSTGRES_USERNAME=postgres
      - PGPOOL_POSTGRES_PASSWORD=${POSTGRESQL_POSTGRES_PASSWORD}

      # üë§ Usuario de aplicaci√≥n (appuser)
      - POSTGRESQL_USERNAME=${POSTGRESQL_USERNAME}
      - POSTGRESQL_PASSWORD=${POSTGRESQL_PASSWORD}
      - POSTGRESQL_DATABASE=${POSTGRESQL_DATABASE}

      # ‚öôÔ∏è Configuraciones de balanceo y failover
      - PGPOOL_ENABLE_LOAD_BALANCING=yes
      - PGPOOL_FAILOVER_ON_BACKEND_ERROR=yes
      - PGPOOL_AUTO_FAILBACK=yes

      # ‚ùóÔ∏è‚ùóÔ∏è CORRECCI√ìN DEFINITIVA ‚ùóÔ∏è‚ùóÔ∏è
      # Usamos 'pcpuser' directamente para evitar el error de variable no definida.
      - PGPOOL_FAILBACK_COMMAND=PCPPASS=${PGPOOL_ADMIN_PASSWORD} pcp_attach_node -h localhost -p 9898 -U admin --node-id=%d

      # ü©∫ Par√°metros de health check
      - PGPOOL_HEALTH_CHECK_PERIOD=10
      - PGPOOL_HEALTH_CHECK_TIMEOUT=8
      - PGPOOL_HEALTH_CHECK_MAX_RETRIES=5
      - PGPOOL_HEALTH_CHECK_RETRY_DELAY=5
      - PGPOOL_CONNECT_TIMEOUT=15
      - PGPOOL_DETACH_STRICT_MODE=no
      - PGPOOL_DEADLOCK_TIMEOUT=30

      # üîê Credenciales de administraci√≥n
      - PGPOOL_ADMIN_USERNAME=admin
      - PGPOOL_ADMIN_PASSWORD=${PGPOOL_ADMIN_PASSWORD}
      - PGPOOL_PCP_USER=pcpuser # Esta variable es para el 'pcp.conf'
      - PGPOOL_PCP_PASSWORD=pcppass # Esta variable es para el 'pcp.conf'
      - PGPOOL_PCP_PORT=9898
      # ‚ùóÔ∏è CORRECCI√ìN 2: LA VARIABLE QUE FALTABA
      # Esto obliga a Bitnami a escribir "pcp_authentication_method = 'md5'" en el .conf
      - PGPOOL_PCP_AUTHENTICATION_METHOD=md5

      # üß† Ajustes de logs y rendimiento
      - PGPOOL_LOG_CONNECTIONS=yes
      - PGPOOL_LOG_STATEMENT=no
      - PGPOOL_LOG_PER_NODE_STATEMENT=no
      - PGPOOL_MAX_POOL=4
      - PGPOOL_NUM_INIT_CHILDREN=32

    ports:
      - "5432:5432"
      - "9898:9898"

  # CLIENTE WEB
  pgadmin:
    image: dpage/pgadmin4
    container_name: pgadmin
    restart: unless-stopped
    environment:
      - PGADMIN_DEFAULT_EMAIL=admin@admin.com
      - PGADMIN_DEFAULT_PASSWORD=admin
      # ESTAS DOS L√çNEAS SON VITALES PARA QUE FUNCIONE TRAS NGINX:
      - PGADMIN_CONFIG_SERVER_MODE=True
      - SCRIPT_NAME=/pgadmin
    expose:
      - "80"
    networks:
      - dbnet

  pgbackups:
    image: prodrigestivill/postgres-backup-local
    container_name: pgbackups
    restart: unless-stopped
    networks: [dbnet]
    environment:
      - POSTGRES_HOST=pgpool
      - POSTGRES_DB=${POSTGRESQL_DATABASE}
      - POSTGRES_USER=${POSTGRESQL_USERNAME}
      - POSTGRES_PASSWORD=${POSTGRESQL_PASSWORD}
      - SCHEDULE=@daily
      - BACKUP_KEEP_DAYS=7
      - BACKUP_KEEP_WEEKS=4
      - BACKUP_KEEP_MONTHS=6
    volumes:
      - ./backups:/backups

  pgoptimizer:
    image: postgres:16
    container_name: pgoptimizer
    restart: unless-stopped
    networks: [dbnet]
    depends_on:
      - pgpool

    environment:
      - PGPASSWORD=${POSTGRESQL_POSTGRES_PASSWORD}
      - PGUSER=postgres
      - PGDATABASE=${POSTGRESQL_DATABASE}
      - PGHOST=pgpool

    volumes:
      - ./scripts/maintenance:/scripts

    command: | # <--- ¬°ESTE ES EL CAMBIO! (De '>' a '|')
      bash -c "
      echo 'üîÑ Iniciando optimizador de base de datos...';

      echo '‚è≥ Esperando a que pgpool est√© listo...';
      while ! pg_isready -h pgpool -U postgres -d ${POSTGRESQL_DATABASE} -q; do
        echo 'pgpool no est√° listo, reintentando en 10 segundos...';
        sleep 10;
      done;

      echo '‚úÖ pgpool est√° listo. Iniciando ciclo de mantenimiento.';

      while true; do
        echo 'üßπ Ejecutando VACUUM ANALYZE...';
        psql -c 'VACUUM (VERBOSE, ANALYZE);';
        
        echo 'üîß Ejecutando REINDEX DATABASE...';
        psql -c 'REINDEX DATABASE ${POSTGRESQL_DATABASE};';
        
        echo '‚úÖ Mantenimiento completado. Esperando 24 horas...';
        sleep 86400;
      done"

  # APLICACI√ìN WEB - BACKEND
  backend-app: # <--- Le damos un nombre de servicio simple
    image: maxisanchez27/hia-backend:latest # <-- A√ëADIMOS ESTA
    container_name: backend-app
    restart: unless-stopped
    expose:
      - "3000"
    networks:
      - dbnet
    depends_on:
      - pgpool # Se asegura de que pgpool inicie primero
    env_file:
      - ./backend_FJV/.env # Inyecta todos los secretos de este archivo
    environment:
      # --- Conexi√≥n a PGPOOL usando tus variables ---
      - DB_HOST=pgpool
      - DB_PORT=5432
      - DB_NAME=${POSTGRESQL_DATABASE}
      - DB_LOGGING=false
      - DB_USER=postgres
      - DB_PASSWORD=${POSTGRESQL_POSTGRES_PASSWORD}

  # APLICACI√ìN WEB - FRONTEND
  frontend-app: # <--- Nombre de servicio para el frontend
    image: maxisanchez27/hia-frontend:latest # <-- A√ëADIMOS ESTA
    container_name: frontend-app
    restart: unless-stopped
    expose:
      - "80"
    networks:
      - dbnet # Lo ponemos en la misma red
    depends_on:
      - backend-app # Se asegura de que el backend inicie primero
  # --- SERVICIOS DE MONITOREO ---

  prometheus:
    image: prom/prometheus:v2.47.1
    container_name: prometheus
    restart: unless-stopped
    networks: [dbnet]
    ports:
      - "9090:9090"
    volumes:
      - ./config/prometheus.yml:/etc/prometheus/prometheus.yml
    profiles: ["monitoring"] # <-- PERFIL

  grafana:
    image: grafana/grafana:10.1.5
    container_name: grafana
    restart: unless-stopped
    networks: [dbnet]
    ports:
      - "3001:3000"
    volumes:
      - grafana-data:/var/lib/grafana
    profiles: ["monitoring"] # <-- PERFIL

  cadvisor:
    image: gcr.io/cadvisor/cadvisor:v0.47.2
    container_name: cadvisor
    restart: unless-stopped
    networks: [dbnet]
    volumes:
      # --- ESTA SECCI√ìN EST√Å CORREGIDA PARA WINDOWS ---
      - /:/rootfs:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro # <-- Usamos el "socket" de Docker
      - /sys:/sys:ro
    profiles: ["monitoring"]

  pg_exporter:
    image: quay.io/prometheuscommunity/postgres-exporter:v0.15.0
    container_name: pg_exporter
    restart: unless-stopped
    networks: [dbnet]
    environment:
      - DATA_SOURCE_NAME=postgresql://postgres:${POSTGRESQL_POSTGRES_PASSWORD}@pgpool:5432/${POSTGRESQL_DATABASE}?sslmode=disable
    depends_on:
      - pgpool
    profiles: ["monitoring"] # <-- PERFIL

  # 5. DESPLIEGUE CONTINUO (Punto 5 - Watchtower)
  watchtower:
    image: containrrr/watchtower
    container_name: watchtower
    restart: unless-stopped
    volumes:
      # Permite a Watchtower controlar el "motor" de Docker
      - /var/run/docker.sock:/var/run/docker.sock
    # Revisa cada 30s, limpia im√°genes viejas,
    # y monitorea *solo* backend-app y frontend-app
    command: --interval 30 --cleanup backend-app frontend-app
    profiles: ["monitoring"] # Lo a√±adimos al perfil de monitoreo

  # --- GATEWAY DE SEGURIDAD (NGINX) ---
  nginx:
    image: nginx:alpine
    container_name: gateway_seguro
    restart: unless-stopped
    ports:
      - "8888:80" # Puerto HTTP (Redirecci√≥n)
      - "443:443" # Puerto HTTPS (Seguro)
    volumes:
      # Carga tu configuraci√≥n personalizada
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      # Carga los certificados que generaste
      - ./certs:/etc/nginx/certs:ro
    networks:
      - dbnet
    depends_on:
      - frontend-app
      - backend-app
      - pgadmin

#testing mi rama